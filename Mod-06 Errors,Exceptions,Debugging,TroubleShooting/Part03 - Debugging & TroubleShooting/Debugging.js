function outer() {
    let name = "outer";
    let str = inner();
    return str;
}

function inner() {
    let name = "inner";
    return "Hello !";
}

// console.log("before outer() call");
// console.log(outer());
// console.log("after outer() call");

// before outer() call
// Hello !
// after outer() call

// Use of the debugger statement

// console.log("before outer() call"); // since we refresh we will only see this
// debugger;
// console.log(outer());
// console.log("after outer() call");


// Resume execution
// To the right of the tab, locate the Resume button (the triangle icon rotated to the right – play). If you hover your mouse over this button, a tooltip should appear so that you can make sure it's the right button. Press this button, or use the keyboard shortcut F8. As a result, the program will move on, and without stopping any more, it will execute to the end by itself. The console should now show the complete information generated by the program:

// before outer() call
// Hello !
// after outer() call


//  How to deal without the debugger statement

// Again, modify the program saved in main.js, this time removing the line containing the debugger command. Save the changes, go back to your browser and reload the page. Obviously the program has executed to the end, but we now know how to stop it. Set two breakpoints, one on the console.log("before outer() call"); the other on the console.log("after outer() call"); (these should now be lines 12 and 14 respectively). Reload the page. The program should stop at the first breakpoint. Clicking Resume will cause the program to resume execution and stop at the second breakpoint.

console.log("before outer() call");
// debugger;
console.log(outer());
console.log("after outer() call");

//<=========>
// Step over, Step Into, Call Stack, Step out
// 6.2.8 Step over F10

// Apart from jumping between successive breakpoints with Resume, we have the possibility to perform a real step-by-step execution (i.e. to call the instructions of our program one at a time). There is a small problem here. If an instruction is a call to a function, should the debugger go inside the function and execute the instructions inside it step by step, or treat it as an indivisible whole and just execute it? Of course, there is no one correct answer, and everything will depend on the specific situation and what we want to achieve. That is why debuggers distinguish between two modes of step execution: Step Into (treating the function as a set of instructions, which we want to execute separately) and Step Over (treating the function call as something indivisible).

// Remove the second breakpoint (from the last line of the code) and reload the page. Locate the Step Over button (to the right of Resume, the arrow arcing over the dot). Press it – the highlight in the code should move to the next line after the breakpoint. At the same time, the console will show the effect of the instruction you just performed.

// Press Step Over twice more (alternatively, use the shortcut F10) observing the changes in the console and code highlighting.

//<=========>
// Step Into
// 6.2.9 Step into

// Let's see what the difference between Step Over and Step Into is in practice. Leave the breakpoint setting unchanged, and reload the page. First execute Step Over (press the button or the F10 shortcut). Then, when we stop at the console.log(outer()) line, execute Step Into.

// What happens? This time the debugger treats the outer function as a set of instructions, jumps inside it and sets itself at its first line. Using Step Into, go further into the inner function, and stop on the return "Hello !" line.

//<=========>
// // Call stack
// 6.2.10 Call stack

// This is a good moment to take a look at another element of the debugger – the Call Stack. In a window with such a name, we can see what function we are currently in (in our case inner). What is more, we will see there all the functions that are currently active. The Call Stack is important in the case of nested functions, like in our example. Using Step Into, we call the outer function in the main program, step into it, and call the inner function. If we stop inside the inner function, then the active functions will be: inner and outer (creating a stack). At the very bottom of the stack, we will see the main function (it doesn't have a name, and in Firefox it is marked as (global), and in Chrome (anonymous)). This is the place from where the outer function is called.

// We stop on line 9, inside the inner function, at the return "Hello !" command. So we are in the context of the inner function at this point. In the console at the bottom of the screen, type the command:

console.log(name); // -> inner

// As a result of its execution, the name "inner" should be displayed (i.e. the contents of the local variable name of the inner function). If you click on the name of the outer function on the Call Stack, you will be taken to the context of that function (note that the selection of the current line has changed). Try calling the same command again in the console:

console.log(name); // -> outer

// This time we should see "outer". We are in the context of the outer function, which has its own local variable named name. This variable contains the word "outer". Click again on the inner function name in the Call Stack to change the context back. Note that despite the context change, the program execution still stops in exactly the same place.

// Viewing and modifying variables

// During the step-by-step execution, we have free access to the variables of our program, which are visible in the context we are currently in. As we have just seen, using the console.log method we can write out the values of such variables. We can also modify them without any problem.
// Let’s go back to the context of the inner function. Run the following sequence of commands in the console:

console.log(name); // -> inner
name = "new name";
console.log(name); // -> new name

// As you can see, we have modified the value of the local variable name, which is located in the inner function. If we continue the program execution (Step or Resume), the program will use this new value.

// Above the Call Stack window is another window called Watch (or Watch expressions). It allows us to view and modify the variables without using the console. In this window, we can find the + button, which after pressing, we can enter the name of the variable whose value changes we want to track. In order to change the current value of a variable, it is enough to double-click in the watch window on the observed variable, and enter the new value. Remember that during function calls or in code blocks, the scope of variable visibility may vary, so don't be surprised if the values of local variables are not visible in the global context.


// Steo out
// 6.2.11 Step out
